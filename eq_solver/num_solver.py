import numpy as np

tau = 1 / 255


class DataBlock:
    def __init__(self, today, option_ask, option_bid, volatility, stock_ask, stock_bid):
        """
        Initializes the DataBlock with given data. Asserts all given data is correct.

        :param option_ask: option ask price for 3 days
        :param option_bid: option bid price for 3 days
        :param volatility: implied volatility for 3 days
        :param stock_ask: current stock ask price
        :param stock_bid: current stock bid price
        """
        self.date = today
        # for i in {option_ask, option_bid, volatility}:
            # assert type(i) == tuple and len(i) == 3
        for i in {stock_ask, stock_bid}:
            assert type(i) == float
        self.u_a = option_ask
        self.u_b = option_bid
        self.sigma = volatility
        self.s_a = stock_ask
        self.s_b = stock_bid
        # Quadratic approximation
        self.ua_fit = find_quad_fit(self.u_a)
        self.ub_fit = find_quad_fit(self.u_b)
        self.sig_fit = find_quad_fit(self.sigma)
        self.ax = find_ax(self.s_a, self.s_b)
        self.initial = initial_value(self.u_a[2], self.u_b[2])
        self.af = None

    def af_system(self, grid_count):
        """
        Returns the Af system of the datablock.
        """
        self.af = system_af(self.ua_fit, self.ub_fit, self.ax, self.sigma, self.initial, grid_count)
        return self.af

    def reg(self, grid_count, beta):
        """
        Regularizes the system.

        :param grid_count: partition grid points count
        :param beta: regularization parameter
        :return: the minimizer of the system
        """
        if self.af is None:
            self.af_system()
        solution = tikhonov(self.af, beta)
        return solution


def find_quad_fit(data):
    fit = np.polyfit([-2 * tau, -1 * tau, 0], data, 2)
    return np.poly1d(fit, variable="t")


def u(data_block):
    """Find the quadratic approximation of u_a, u_b on the given day.

    Parameters
    ----------
    data_block : ndarray
        The block of data.

    Returns
    -------
    (u_a, u_b) : (poly1d, poly1d)
        The equations for u_a and u_b.
    """
    ask_data = data_block.iloc[0:3, 2:3].values.squeeze()
    bid_data = data_block.iloc[0:3, 3:4].values.squeeze()
    ask_fit = np.polyfit([-2 * tau, -1 * tau, 0], ask_data, 2)
    bid_fit = np.polyfit([-2 * tau, -1 * tau, 0], bid_data, 2)
    u_a = np.poly1d(ask_fit, variable='t')
    u_b = np.poly1d(bid_fit, variable='t')
    return u_a, u_b


def sigma(data_block):
    """Find the volatility sigma on the given day.

    Similar to u(date_index).

    Returns
    -------
    sigma : poly1d
        The equation for volatility.
    """
    vola_data = data_block.iloc[0:3, 7:8].values.squeeze()
    vola_fit = np.polyfit([-2 * tau, -1 * tau, 0], vola_data, 2)
    out = np.poly1d(vola_fit, variable='t')
    return out


def find_sab(data_block):
    """Returns the sa, sb value at the given day.
    """
    s_a = data_block.iloc[2, 5]
    s_b = data_block.iloc[2, 6]
    return s_a, s_b


def find_ax(s_a, s_b):
    """Returns a function evaluating A(x) on the given day.
    """
    diff = s_a - s_b
    return lambda x: (255 / 2) * (((x * diff) + s_b) ** 2) / (diff ** 2)


def initial_value(ua, ub):
    """Returns the initial value at u(x, 0).
    """
    return lambda x: (ua - ub) * x + ub


def system_af(u_a, u_b, a_x, vola, initial, m):
    """Returns the matrix A generated by all conditions.

    Parameters
    ----------
    u_a : numpy.poly1d
        option ask price function

    u_b : numpy.poly1d
        option bid price function

    a_x : double -> double
        A(x)

    vola : numpy.poly1d
        sigma(x)

    initial : double -> double
        initial value

    m : int
        M,N value (grid_count)
        Notice that grid_count > 2.

    Returns
    -------
    the matrix A and the vector f
    """
    A = np.zeros((m ** 2, m ** 2))
    f = np.zeros(m ** 2)

    h_x = 1 / m
    h_t = 3 * tau / m

    line_count = 0
    for i in range(m - 1):
        for j in range(1, m - 1):
            Ax = a_x(j * h_x)
            sigma2 = np.polyval(vola, i * h_x) ** 2
            A[line_count][i * m + j] = h_x ** 2 - 2 * sigma2 * Ax * h_t
            A[line_count][i * m + j - m] = - h_x ** 2
            A[line_count][i * m + j + 1] = sigma2 * Ax * h_t
            A[line_count][i * m + j - 1] = sigma2 * Ax * h_t
            line_count += 1

    for i in range(m):
        A[line_count][i] = 1
        f[line_count] = initial(i * h_x)
        line_count += 1

    for i in range(1, m):
        A[line_count][i * m] = 1
        f[line_count] = np.polyval(u_b, (i * h_t))
        line_count += 1
        A[line_count][i * m + (m - 1)] = 1
        f[line_count] = np.polyval(u_a, (i * h_t))
        line_count += 1

    return A, f

    # Below is the old code.
    # matrix = []
    # f = []

    # h_x = 1 / m
    # h_t = 3 * tau / m

    # # Finite difference scheme
    # for i in range(m - 1):  # 0 to (M - 2)
    #     for j in range(1, m - 1):  # 1 to (M - 2)
    #         Ax = a_x(j * h_x)
    #         sigma2 = np.polyval(vola, i * h_x) ** 2
    #         row = np.zeros(m ** 2)
    #         row[i * m + j] = (h_x ** 2 - 2 * sigma2 * Ax * h_t)
    #         row[i * m + j - m] = - h_x ** 2
    #         row[i * m + j + 1] = sigma2 * Ax * h_t
    #         row[i * m + j - 1] = sigma2 * Ax * h_t
    #         matrix.append(row)
    #         f.append(0.0)

    # # Boundary & initial conditions
    # for i in range(m - 1):
    #     row_a = np.zeros(m ** 2)
    #     row_b = np.zeros(m ** 2)
    #     row_init = np.zeros(m ** 2)
    #     row_a[i] = 1
    #     matrix.append(row_a)
    #     f.append(np.polyval(u_a, (i * h_t)))
    #     row_b[i] = 1
    #     matrix.append(row_b)
    #     f.append(np.polyval(u_b, (i * h_t)))
    #     row_init[i] = 1
    #     matrix.append(row_init)
    #     f.append(initial(i * h_x))

    # return matrix, f


def tikhonov(matrix, f, beta):
    """
    Uses Tikhonov Regularization to minimize the system.
    :param matrix: A
    :param f: f
    :param beta: regularization parameter
    :return: minimized U
    """
    n, d = matrix.shape
    coef = np.dot(matrix.T, matrix) + beta * np.identity(n)
    left = np.linalg.pinv(coef)
    right = np.dot(matrix.T, f)
    return np.dot(left, right)
    # right = np.matmul(matrix_trans, f)
    # matrix_trans = np.transpose(matrix)
    # left = np.linalg.inv(np.add(np.matmul(matrix_trans, matrix), beta * np.identity(len(matrix[0]))))
    # return np.matmul(left, right)
